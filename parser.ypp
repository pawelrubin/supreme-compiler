%{
  #include <string>
  #include <iostream>

  #include "code.hpp"
  #include "data.hpp"
  #include "typedefs.hpp"
  #include "types.hpp"

  int yylex (void);
  extern FILE *yyin;
  extern int yylineno;
  extern char *yytext;
  void yyerror (std::string);

  TProgram* program;

  Data *data = new Data();
  Code *code = new Code();
%}

%define parse.error verbose 

// semantic record
%union sem_rec {
  ident *pidentifier;
  integer num;
  TCommandBlock *cblock;
  TCommand *command;
  TExpression *expr;
  TValue *val;
  TCondition *cond;
  TIdentifier *id;
}

// tokens
%start program
%token DECLARE T_BEGIN END
%token ASSIGN
%token IF WHILE DO
%token FOR
%token THEN ELSE ENDIF ENDWHILE ENDDO FROM TO DOWNTO ENDFOR
%token READ WRITE
%token EQ NEQ LE GE LEQ GEQ

%token <pidentifier> pidentifier
%token <num> num

// types
%type <cblock> commands;
%type <command> command;
%type <expr> expression
%type <cond> condition
%type <val> value
%type <id> identifier

// operators
%left PLUS MINUS
%left TIMES DIV MOD

// errors
%token ERROR_INVALID_CHARACTER ERROR_NESTED_COMMENT


%% /* The grammar follows. */

program:
  DECLARE declarations T_BEGIN commands END                   { program = new TProgram($4); }
| T_BEGIN commands END                                        { program = new TProgram($2);                     }
;

declarations: 
  declarations ',' pidentifier                                { data->declare_variable(*$3);      }
| declarations ',' pidentifier '(' num ':' num ')'            { data->declare_array(*$3, $5, $7); }
| pidentifier                                                 { data->declare_variable(*$1);      }
| pidentifier '(' num ':' num ')'                             { data->declare_array(*$1, $3, $5); }
;

commands:
  commands command                                            { $1->add_command($2); $$ = $1; }
| command                                                     { $$ = new TCommandBlock($1);   }
;

command:
  identifier ASSIGN expression ';'                            { $$ = new TAssignCommand($1, $3);            }
| IF condition THEN commands ELSE commands ENDIF              { $$ = new TIfElseCommand($2, $4, $6);        }
| IF condition THEN commands ENDIF                            { $$ = new TIfCommand($2, $4);                }
| WHILE condition DO commands ENDWHILE                        { $$ = new TWhileCommand($2, $4);             }
| DO commands WHILE condition ENDDO                           { $$ = new TDoWhileCommand($2, $4);           }
| FOR pidentifier FROM value TO value DO commands ENDFOR      { $$ = new TForToCommand(*$2, $4, $6, $8);    }
| FOR pidentifier FROM value DOWNTO value DO commands ENDFOR  { $$ = new TForDownToCommand(*$2, $4, $6, $8);}
| READ identifier ';'                                         { $$ = new TReadCommand($2);                  }
| WRITE value ';'                                             { $$ = new TWriteCommand($2);                 }
;

expression:
  value                                                       { $$ = new TValueExpression($1);                             }
| value PLUS value                                            { $$ = new TBinaryExpression($1, $3, BinaryOperator::PLUS);  }
| value MINUS value                                           { $$ = new TBinaryExpression($1, $3, BinaryOperator::MINUS); }
| value TIMES value                                           { $$ = new TBinaryExpression($1, $3, BinaryOperator::TIMES); }
| value DIV value                                             { $$ = new TBinaryExpression($1, $3, BinaryOperator::DIV);   }
| value MOD value                                             { $$ = new TBinaryExpression($1, $3, BinaryOperator::MOD);   }
;

condition:
  value EQ value                                              { $$ = new TCondition($1, $3, ConditionOperator::EQ);  }
| value NEQ value                                             { $$ = new TCondition($1, $3, ConditionOperator::NEQ); }
| value LE value                                              { $$ = new TCondition($1, $3, ConditionOperator::LE);  }
| value GE value                                              { $$ = new TCondition($1, $3, ConditionOperator::GE);  }
| value LEQ value                                             { $$ = new TCondition($1, $3, ConditionOperator::LEQ); }
| value GEQ value                                             { $$ = new TCondition($1, $3, ConditionOperator::GEQ); }
;

value:
  num                                                         { $$ = new NumberValue($1);     }
| identifier                                                  { $$ = new IdentifierValue($1); }
;

identifier:
  pidentifier                                                 { $$ = new TVariableIdentifier(*$1);           }
| pidentifier '(' pidentifier ')'                             { $$ = new TArrayVariableIdentifier(*$1, *$3); }
| pidentifier '(' num ')'                                     { $$ = new TArrayNumIdentifier(*$1, $3);       }
;

%%

void yyerror(std::string s) {
  std::cerr << "[ ERROR IN LINE " + std::to_string(yylineno) + " ] " 
            << "yytext: \"" << std::string(yytext) << "\"; "
            << "error message: " << s << std::endl;
  exit(1);
}

int main(int argc, char **argv) {
  
  if (argc < 3) {
    std::cerr << "Not enough arguments" << std::endl;
    exit(1);
  }
  
  yyin = fopen(argv[1], "r");
  
  if (yyin != NULL) {
    try {
      yyparse();
      std::cout << "Parsed successfully" << std::endl;
      program->load_program();
      std::cout << "Compiled successfully" << std::endl;
      code->fprint_code(argv[2]);
    } catch(std::string msg) {
      yyerror(msg);
    }
  } else {
    exit(2);
  }
}
