%{
  #include <string>
  #include <iostream>

  #include "code.hpp"
  #include "data.hpp"
  #include "typedefs.hpp"
  #include "types.hpp"

  int yylex (void);
  extern FILE *yyin;
  extern int yylineno;
  extern char *yytext;
  void yyerror (std::string);

  Data *data = new Data();
  Code *code = new Code();
%}

%define parse.error verbose 

// semantic record
%union sem_rec {
  ident *pidentifier;
  integer num;
  TValue *val;
  TExpression *expr;
  TIdentifier *id;
}

// tokens
%start program
%token DECLARE T_BEGIN END
%token ASSIGN
%token IF WHILE DO
%token FOR
%token THEN ELSE ENDIF ENDWHILE ENDDO FROM TO DOWNTO ENDFOR
%token READ WRITE
%token EQ NEQ LE GE LEQ GEQ

%token <pidentifier> pidentifier
%token <num> num

// types
%type <val> value
%type <expr> expression
%type <id> identifier

// operators
%left PLUS MINUS
%left TIMES DIV MOD

// errors
%token ERROR_INVALID_CHARACTER ERROR_NESTED_COMMENT


%% /* The grammar follows. */

program:
  DECLARE declarations T_BEGIN commands END                   { code->end_code(); }
| T_BEGIN commands END                                        { code->end_code(); }
;

declarations: 
  declarations ',' pidentifier                                { data->declare_variable(*$3);      }
| declarations ',' pidentifier '(' num ':' num ')'            { data->declare_array(*$3, $5, $7); }
| pidentifier                                                 { data->declare_variable(*$1);      }
| pidentifier '(' num ':' num ')'                             { data->declare_array(*$1, $3, $5); }
;

commands:
  commands command                                            { }
| command                                                     { }
;

command:
  identifier ASSIGN expression ';'                            { code->assign($1, $3); }
| IF condition THEN commands ELSE commands ENDIF              {                       }
| IF condition THEN commands ENDIF                            {                       }
| WHILE condition DO commands ENDWHILE                        {                       }
| DO commands WHILE condition ENDDO                           {                       }
| FOR pidentifier FROM value TO value DO commands ENDFOR      {                       }
| FOR pidentifier FROM value DOWNTO value DO commands ENDFOR  {                       }
| READ identifier ';'                                         { code->read($2);       }
| WRITE value ';'                                             { code->write($2);      }
;

expression:
  value                                                       { $$ = new TValueExpression($1);                             }
| value PLUS value                                            { $$ = new TBinaryExpression($1, $3, BinaryOperator::PLUS);  }
| value MINUS value                                           { $$ = new TBinaryExpression($1, $3, BinaryOperator::MINUS); }
| value TIMES value                                           { $$ = new TBinaryExpression($1, $3, BinaryOperator::TIMES); }
| value DIV value                                             { $$ = new TBinaryExpression($1, $3, BinaryOperator::DIV);   }
| value MOD value                                             { $$ = new TBinaryExpression($1, $3, BinaryOperator::MOD);   }
;

condition:
  value EQ value                                              { }
| value NEQ value                                             { }
| value LE value                                              { }
| value GE value                                              { }
| value LEQ value                                             { }
| value GEQ value                                             { }
;

value:
  num                                                         { $$ = new NumberValue($1);     }
| identifier                                                  { $$ = new IdentifierValue($1); }
;

identifier:
  pidentifier                                                 { $$ = new TVariableIdentifier(*$1);           }
| pidentifier '(' pidentifier ')'                             { $$ = new TArrayVariableIdentifier(*$1, *$3); }
| pidentifier '(' num ')'                                     { $$ = new TArrayNumIdentifier(*$1, $3);       }
;

%%

void yyerror(std::string s) {
  std::cerr << "[ ERROR IN LINE " + std::to_string(yylineno) + " ] " 
            << "yytext: \"" << std::string(yytext) << "\"; "
            << "error message: " << s << std::endl;
  exit(1);
}

int main(int argc, char **argv) {
  
  if (argc < 3) {
    std::cerr << "Not enough arguments" << std::endl;
    exit(1);
  }
  
  yyin = fopen(argv[1], "r");
  
  if (yyin != NULL) {
    try {
      yyparse();
      std::cout << "Compiled successfully" << std::endl;
      // data->print_symbols();
      // code->print_code();
      code->fprint_code(argv[2]);
    } catch(std::string msg) {
      yyerror(msg);
    }
  } else {
    exit(2);
  }
}
