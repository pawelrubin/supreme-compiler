%{
  #include <string>
  #include <iostream>

  #include "data.hpp"

  int yylex (void);
  extern FILE *yyin;
  extern int yylineno;
  extern char *yytext;
  void yyerror (std::string);

  Data *data = new Data();

%}

%define parse.error verbose 

// semantic record
%union sem_rec {
  std::string *pidentifier;
  long long num;
}

// tokens
%start program
%token DECLARE T_BEGIN END
%token ASSIGN
%token IF WHILE DO
%token FOR
%token THEN ELSE ENDIF ENDWHILE ENDDO FROM TO DOWNTO ENDFOR
%token READ WRITE
%token EQ NEQ LE GE LEQ GEQ

%token <pidentifier> pidentifier
%token <num> num

// types

// operators
%left PLUS MINUS
%left TIMES DIV MOD

// errors
%token ERROR_INVALID_CHARACTER ERROR_NESTED_COMMENT


%% /* The grammar follows. */

program:
  DECLARE declarations T_BEGIN commands END                   {}
| T_BEGIN commands END                                        {}
;

declarations: 
  declarations ',' pidentifier                                { data->declare_variable(*$3); }
| declarations ',' pidentifier '(' num ':' num ')'            { data->declare_array(*$3, $5, $7); }
| pidentifier                                                 { data->declare_variable(*$1); }
| pidentifier '(' num ':' num ')'                             { data->declare_array(*$1, $3, $5); }
;

commands:
  commands command                                            {}
| command                                                     {}
;

command:
  identifier ASSIGN expression ';'                            { }
| IF condition THEN commands ELSE commands ENDIF              {}
| IF condition THEN commands ENDIF                            {}
| WHILE condition DO commands ENDWHILE                        {}
| DO commands WHILE condition ENDDO                           {}
| FOR pidentifier FROM value TO value DO commands ENDFOR      {}
| FOR pidentifier FROM value DOWNTO value DO commands ENDFOR  {}
| READ identifier ';'                                         {}
| WRITE value ';'                                             {}
;

expression:
  value                                                       {}
| value PLUS value                                            {}
| value MINUS value                                           {}
| value TIMES value                                           {}
| value DIV value                                             {}
| value MOD value                                             {}
;

condition:
  value EQ value                                              {}
| value NEQ value                                             {}
| value LE value                                              {}
| value GE value                                              {}
| value LEQ value                                             {}
| value GEQ value                                             {}
;

value:
  num                                                         { /* $$ = $1; std::cerr << "num: " << $1 << std::endl;*/ };
| identifier                                                  { /* $$ = variables[$1]; */ }
;

identifier:
  pidentifier                                                 {}
| pidentifier '(' pidentifier ')'                             {}
| pidentifier '(' num ')'                                     {}
;

%%

void yyerror(std::string s) 
{
  std::cerr << "[ ERROR IN LINE " + std::to_string(yylineno) + " ] " 
            << "yytext: \"" << std::string(yytext) << "\"; "
            << "error message: " << s << std::endl;
}

int main(int argc, char **argv)
{
  yyin = fopen(argv[1], "r");
  if (yyin != NULL)
  {
    try {
      yyparse();
      data->print_symbols();
    } catch(std::string msg) {
      yyerror(msg);
    }
  } 
}
